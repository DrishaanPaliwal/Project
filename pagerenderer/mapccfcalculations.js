
'strict mode'


class MapCCFCalculations {
    self;
    WIDTH = 8192;
    HEIGHT = 3365;
    
    progressText;
    PromptMissingInfoContainer;
    PromptedMissingInfoCanvas;
    PromptLabel;
    PromptField;
    submitButton;
    copyToClipboardButton;

    PromptFieldReturnedText = "";
    
    autoGeneratedCffTextField = "";

    constructor(){
        self = this;
        document.querySelector("body").addEventListener("game load done", self.scanMaps);

        self.progressText = document.querySelector(".progressText");
        self.progressText.innerText = "Loading...";
        self.PromptMissingInfoContainer = document.querySelector(".promptMissingInfoContainer");
        self.PromptedMissingInfoCanvas = document.querySelector(".promptMissingInfoContainer canvas");
        self.PromptedMissingInfoCanvas.width = self.WIDTH;
        self.PromptedMissingInfoCanvas.height = self.HEIGHT;
        self.PromptLabel = document.querySelector(".promptMissingInfoContainer label");
        self.PromptField = document.querySelector(".promptMissingInfoContainer .promptField");
    
        self.submitButton = document.querySelector(".promptMissingInfoContainer .promptButton");
        self.submitButton.addEventListener("click", function () {
            self.PromptFieldReturnedText = self.PromptField.value;
            self.PromptMissingInfoContainer.hidden = true;
        });
        self.autoGeneratedCffTextField = document.querySelector(".autoGeneratedCffTextField");

        
        self.copyToClipboardButton = document.querySelector("button#clipboard");

        
        self.copyToClipboardButton.onclick = function () {
            
            // Select the text field
            self.autoGeneratedCffTextField.select();
            self.autoGeneratedCffTextField.setSelectionRange(0, 99999); // For mobile devices
            navigator.clipboard.writeText(self.autoGeneratedCffTextField.value);
        }
    }

    baseData;
    nationData;
    climateData;
    coastData;
    developmentData;
    cultureData;
    religionData;
    tradeZoneData;

    nationColorProperties;
    climateColorProperties; 
    cultureColorProperties; 
    religionColorProperties;
    tradeZoneColorProperties;

    async scanMaps() {
        self.nationColorProperties = self.fillInColorProperties(gameStats.Nations);
        self.climateColorProperties = self.fillInColorProperties(gameStats.Climates);
        self.cultureColorProperties = self.fillInColorProperties(gameStats.Cultures);
        self.religionColorProperties = self.fillInColorProperties(gameStats.Religions);
        self.tradeZoneColorProperties = self.fillInColorProperties(gameStats.TradeZones);

        self.baseData = await prepareData("Blank.png", self.progressText)
        
        self.nationData = await prepareData("Nations.png", self.progressText)
        self.climateData = await prepareData("Climates.png", self.progressText)
        self.coastData = await prepareData("CoastalLand.png", self.progressText)
        self.developmentData = await prepareData("Development.png", self.progressText)
        self.cultureData = await prepareData("Cultures.png", self.progressText)
        self.religionData = await prepareData("Religions.png", self.progressText)
        self.tradeZoneData = await prepareData("TradeZones.png", self.progressText)

        self.progressText.innerText = "loading population X development";
        await new Promise(resolve => setTimeout(resolve));

        let populationXDevelopmentData = self.mergeMaps(self.populationXDevelopmentMerger);
        let populationXDevelopmentBonusData = self.mergeMaps(self.populationXDevelopmentBonusMerger);

        const colorToCoastMap = [
            { color: "00ffff", name: "coast"}
        ];

        let climateDistribution = await self.findDistribution(
            self.nationData, self.climateData, "nation", "climate",
            self.nationColorProperties,
            self.climateColorProperties, 
            {
                unassignedPixelAssumption: "Moderate"
            }
        );

        let coastPixelCount = await self.findDistribution(
            self.nationData, self.coastData, "nation", "coast", 
            self.nationColorProperties,
            colorToCoastMap, 
            {
                unassignedPixelAssumption: "Noncoast",
                canIgnoreTransparentInner: true
            }
        );
        
        let developmentScore = await self.findDistribution(
            self.nationData, self.developmentData, "nation", "development",
            self.nationColorProperties,
            0,
            {
                canIgnoreTransparentInner: true,
                greyScale: true 
            }
        );
    
        let cultureDistribution = await self.findDistribution(
            self.nationData, self.cultureData, "nation", "culture", 
            self.nationColorProperties,
            self.cultureColorProperties,
            {
                unassignedPixelAssumption: "Foreign"
            } 
        );

        let religionDistribution = await self.findDistribution(
            self.nationData, self.religionData, "nation", "religion", 
            self.nationColorProperties,
            self.religionColorProperties, 
            {
                unassignedPixelAssumption: "Pagan"
            }
        );


        let tradeZoneScore = await self.findDistribution(
            self.tradeZoneData, populationXDevelopmentData, "trade zone", "wealth",
            self.tradeZoneColorProperties,
            0,
            {
                canIgnoreTransparentInner: true,
                greyScale: true,
                unassignedPixelAssumption: 0
            }
        );

        self.autoGeneratedCffTextField.value += 
        `<... > Nations
        !suppress 99999
        
        `.trimIndents();

        //divide to make all constituencies make up 100(%). 
        Object.keys(cultureDistribution).forEach(nationKey => {
            
            let total = 0.0;

            //finding the total of all culturekey values in this nation, so we got something to divide by to find the constituencies' ratios
            Object.keys(cultureDistribution[nationKey]).forEach(CultureKey => {
                total += cultureDistribution[nationKey][CultureKey];
            });

            //replace CultureGroups by empty, before re-initialising every culture in it from scratch
            
            self.autoGeneratedCffTextField.value += 
                `> ${nationKey}
                +> CultureGroups
                > CultureGroups
                `.trimIndents();
            //dividing and adding to self.autoGeneratedCffTextField
            Object.keys(cultureDistribution[nationKey]).forEach(CultureKey => {

                self.autoGeneratedCffTextField.value += `+> ${CultureKey}\n`
                self.autoGeneratedCffTextField.value += `= ${cultureDistribution[nationKey][CultureKey] * 100 / total} ${CultureKey}.Points\n`
            });
            
            self.autoGeneratedCffTextField.value += 
                `< <
                `.trimIndents();
        });

        //divide to make all constituencies make up 100(%). 
        
        Object.keys(religionDistribution).forEach(nationKey => {
            
            let total = 0.0;

            //finding the total of all religionkey values in this nation, so we got something to divide by to find the constituencies' ratios
            Object.keys(religionDistribution[nationKey]).forEach(ReligionKey => {
                total += religionDistribution[nationKey][ReligionKey];
            });

            //replace ReligionGroups by empty, before re-initialising every religion in it from scratch
            self.autoGeneratedCffTextField.value += 
                `> ${nationKey}
                +> ReligionGroups
                > ReligionGroups
                `.trimIndents();
            //dividing and adding to self.autoGeneratedCffTextField
            Object.keys(religionDistribution[nationKey]).forEach(ReligionKey => {

                self.autoGeneratedCffTextField.value += `+> ${ReligionKey}\n`
                self.autoGeneratedCffTextField.value += `= ${religionDistribution[nationKey][ReligionKey] * 100 / total} ${ReligionKey}.Points\n`
            });
            
            self.autoGeneratedCffTextField.value += 
                `< <
                `.trimIndents();
        });

        //add climate distributions to autogeneratedccf
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        Object.keys(climateDistribution).forEach(nationKey => {
            
            
            Object.keys(climateDistribution[nationKey]).forEach(climateKey => {
                self.autoGeneratedCffTextField.value += `= ${climateDistribution[nationKey][climateKey]} ${nationKey}.${climateKey}\n`;
            });
            
        });

        //add development distributions to autogeneratedccf
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        Object.keys(developmentScore).forEach(nationKey => {
            self.autoGeneratedCffTextField.value += `= ${developmentScore[nationKey]} ${nationKey}.DevelopmentPixelCount\n`;
        });
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();

        //add coast distributions to autogeneratedccf
        
        Object.keys(coastPixelCount).forEach(nationKey => {
            
            self.autoGeneratedCffTextField.value += `= ${coastPixelCount[nationKey].coast} ${nationKey}.CoastalPixels\n`;
        });

        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        /* #region  Everthing resources */

        for (let r = 0; r < mappedResources.length; r++) {
            let resourceName = mappedResources[r];
            
            let resourceData = null;
            
            resourceData = await prepareData(`ResourcesForCode/${resourceName}.png`);
            
            self.progressText.innerText = "";

            let resourceBlobSizes = (await self.findDistribution(
                () => {return 255}, resourceData, "world", resourceName,
                [{ color: "ffffff", name: "world"}],
                (e) => { return {color: e, name: "Col" + e}},
                {
                    skipsTransparentInner: true,
                    unnamedGroup: true
                }
            ))["world"];

            //find nations' max resources

            let resourceOverlap = await self.findDistribution(
                self.nationData, resourceData, "nation", resourceName,
                self.nationColorProperties,
                (e) => { return {color: e, name: "Col" + e}},
                {
                    skipsTransparentInner: true,
                    unnamedGroup: true
                }
            );
            
            //use resourceBlobSizes to divide all. 
            
            Object.keys(resourceOverlap).forEach(nationKey => {
                let count = 0.0;

                //counting up all pixels overlapping per blob, divided by the blob's size
                Object.keys(resourceOverlap[nationKey]).forEach(ColorKey => {
                    count += resourceOverlap[nationKey][ColorKey] / resourceBlobSizes[ColorKey];
                });

                //resource blob number multiplication
                count *= mappedResourcesMultipliers[r];

                self.autoGeneratedCffTextField.value += 
                    `= ${(Math.round((count*20)) / 20).toFixed(2)} ${nationKey}.Max${resourceName}
                    `.trimIndents();
            });

        }
        
        /* #endregion */

        //add trade zone wealths to autogeneratedccf

        self.autoGeneratedCffTextField.value += 
        `
        <... > TradeZones
        `.trimIndents();


        //climate * totaldevscore (255 per pixel)
        Object.keys(tradeZoneScore).forEach(zoneKey => {
            let rawTradeZoneScore = tradeZoneScore[zoneKey];
            let idealTradeZoneScore = rawTradeZoneScore / 10000;
            self.autoGeneratedCffTextField.value += `= ${(Math.round((idealTradeZoneScore*20)) / 20).toFixed(2)} ${zoneKey}.Score\n`;
        });

        self.autoGeneratedCffTextField.value += 
        `!suppress 0
        <...
        `.trimIndents();
        
        self.progressText.innerText = `Done`

        //add to autogeneratedccf
        
        self.copyToClipboardButton.disabled = false;
    }

    fillInColorProperties(searchObj){
        let ret = [];

        Object.keys(searchObj).forEach(key => {
            ret.push({color: searchObj[key].Color, name: key});
        });

        return ret;

    }

    async findDistribution(outerDataset, innerDataset, outerName, innerName, colorToOuterNameMapping, colorToInnerNameMapping, options) {
        let ret = {};
        let pixelCount = self.WIDTH * self.HEIGHT;
        if(options.pixelCount){
            pixelCount = options.pixelCount;
        }

        let getOuterDataPoint;
        let getInnerDataPoint;

        if(typeof outerDataset != 'function')
            getOuterDataPoint = (i) => outerDataset[i];
        else
            getOuterDataPoint = (i) => outerDataset(i);

        if(typeof innerDataset != 'function')
            getInnerDataPoint = (i) => innerDataset[i];
        else
            getInnerDataPoint = (i) => innerDataset(i);

        let then = Date.now();
        for (let i = 0; i < pixelCount; i++) {
            
            let x = i % self.WIDTH;
            let y = Math.floor(i / self.WIDTH);

            //let the site know you're still alive
            let now = Date.now();
            if (now - then > 500) {
                self.progressText.innerText = `counting ${innerName}s in ${outerName}s:\n\n${i} out of ${pixelCount} pixels read.\nThat's row ${Math.floor(i / self.WIDTH)} out of ${self.HEIGHT}`
                await new Promise(resolve => setTimeout(resolve));
                then = now;
            }
            
            let outerCol;
            let innerCol;

            let isOuterDataEmpty = getOuterDataPoint(i*4+3) == 0;
            let isInnerDataEmpty = getInnerDataPoint(i*4+3) == 0;

            //if the pixel in outerDataset is transparent, skip
            if(isOuterDataEmpty) continue;
            //if the pixel in innerDataset is transparent, warn
            else if(isInnerDataEmpty) {
                if (options.skipsTransparentInner)
                    continue;
                else if(!options.canIgnoreTransparentInner)
                    console.warn(`The pixel (${x}, ${y}) is transparent in the ${innerName} image, but not the ${outerName} image. It is (${getOuterDataPoint(i*4)}, ${getOuterDataPoint(i*4+1)}, ${getOuterDataPoint(i*4+2)}, ${getOuterDataPoint(i*4+3)}) in the ${outerName} image. Investigate this. For now ${options.unassignedPixelAssumption} is assumed`);
            }

            outerCol = rgbToHex([getOuterDataPoint(i*4), getOuterDataPoint(i*4+1), getOuterDataPoint(i*4+2)]);
            innerCol = rgbToHex([getInnerDataPoint(i*4), getInnerDataPoint(i*4+1), getInnerDataPoint(i*4+2)]);

            let foundOuterObject = colorToOuterNameMapping.find(element => element.color == outerCol);

            if(typeof foundOuterObject === 'undefined') {
                foundOuterObject = await PromptName(outerCol, getOuterDataPoint, outerName);
                colorToOuterNameMapping.push(foundOuterObject);
            }

            const OuterNameOfPixel = foundOuterObject.name;

            if(!options.greyScale){
                let foundInnerObject = 
                    isInnerDataEmpty ? 
                        options.unassignedPixelAssumption : 
                        !options.unnamedGroup ? 
                            colorToInnerNameMapping.find(element => element.color == innerCol):
                            {color: innerCol, name: "Col" + innerCol};
                if(typeof foundInnerObject === 'undefined'){
                    foundInnerObject = await PromptName(innerCol, getInnerDataPoint, innerName);
                    if (!options.unnamedGroup) colorToInnerNameMapping.push(foundInnerObject);
                }
                
                const InnerNameOfPixel = foundInnerObject.name;

                if(typeof ret[OuterNameOfPixel] === 'undefined') ret[OuterNameOfPixel] = {};
                if(typeof ret[OuterNameOfPixel][InnerNameOfPixel] === 'undefined') ret[OuterNameOfPixel][InnerNameOfPixel] = 0;
                
                ret[OuterNameOfPixel][InnerNameOfPixel]++;
            }else{
                const innerGreyScale = getInnerDataPoint(i*4);
                const InnerPixelValue = isInnerDataEmpty ? options.unassignedPixelAssumption : 255 - innerGreyScale;
                
                if(typeof ret[OuterNameOfPixel] === 'undefined') ret[OuterNameOfPixel] = 0;
                
                ret[OuterNameOfPixel] += InnerPixelValue;
            }
        }

        return ret;
    }

    async PromptName(color, getDatasetPointFunction, name){
        self.PromptFieldReturnedText = "";
        
        let DatasetLength = self.WIDTH * self.HEIGHT * 4;

        self.PromptMissingInfoContainer.hidden = false;
        self.PromptLabel.innerText = `The color #${color} did not have a matching ${name}. Which ${name} is it?\n(Give the name it has in stats)`;
        let dat = new Uint8ClampedArray(DatasetLength);
        for (let j = 0; j < DatasetLength; j++) {
            dat[j] = getDatasetPointFunction(j);
            
        }
        for(let j = 0; j < dat.length / 4; j++){
            if(rgbToHex([getDatasetPointFunction(j*4), getDatasetPointFunction(j*4+1), getDatasetPointFunction(j*4+2)]) == color){
                dat[j*4] = getDatasetPointFunction(j*4);
                dat[j*4+1] = getDatasetPointFunction(j*4+1);
                dat[j*4+2] = getDatasetPointFunction(j*4+2);
                dat[j*4+3] = getDatasetPointFunction(j*4+3);
            }
            else {
                dat[j*4] = self.baseData[j*4];
                dat[j*4+1] = self.baseData[j*4+1];
                dat[j*4+2] = self.baseData[j*4+2];
                dat[j*4+3] = self.baseData[j*4+3];
            }
            
        }

        dat = new ImageData(dat, self.WIDTH);

        self.PromptedMissingInfoCanvas.getContext("2d").putImageData(dat, 0, 0);

        console.log("ok, just waiting now :)");

        //idle until cultureNamePrompt answered;
        let then = Date.now();
        while(self.PromptFieldReturnedText == ""){
            let now = Date.now();
            if (now - then > 17) {
                await new Promise(resolve => setTimeout(resolve));
                then = now;
            }
        }

        let ret = {
            color: color, 
            name: self.PromptFieldReturnedText
        };

        self.autoGeneratedCffTextField.value += `= "${color}" ${name}s.${self.PromptFieldReturnedText}.Color\n`

        return ret;
    }

    mergeMaps(delegate){
        let ret = new Uint16Array(self.WIDTH * self.HEIGHT * 4);

            for(let i = 0; i < ret.length / 4; i++) {
                ret[i] = delegate(i);
            }

        return ret;
    }

    populationXDevelopmentMerger(mapIndex){
        let foundZoneColor = rgbToHex([self.nationData[mapIndex*4], self.nationData[mapIndex*4+1], self.nationData[mapIndex*4+2]]);
        let climateObject = self.climateColorProperties.find(element => element.color == foundZoneColor);
        let climateScore = climateObject ? gameStats.Climates[climateObject.name].ClimateScore : 0;
        return climateScore * self.developmentData[mapIndex];
    }

    populationXDevelopmentBonusMerger(mapIndex){
        let foundZoneColor = rgbToHex([self.nationData[mapIndex*4], self.nationData[mapIndex*4+1], self.nationData[mapIndex*4+2]]);
        let climateObject = self.climateColorProperties.find(element => element.color == foundZoneColor);
        let climateScore = climateObject ? gameStats.Climates[climateObject.name].ClimateScore : 0;
        return climateScore * (128 + self.developmentData[mapIndex] / 2);
    }
}

new MapCCFCalculations();
