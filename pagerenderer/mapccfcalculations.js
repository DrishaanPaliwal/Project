
'strict mode'


class MapCCFCalculations {
    self;
    WIDTH = 8192;
    HEIGHT = 3365;
    
    progressText;
    PromptMissingInfoContainer;
    PromptedMissingInfoCanvas;
    PromptLabel;
    PromptField;
    submitButton;
    copyToClipboardButton;

    PromptFieldReturnedText = "";
    
    autoGeneratedCffTextField = "";

    constructor(){
        self = this;
        document.querySelector("body").addEventListener("game load done", self.scanMaps);

        self.progressText = document.querySelector(".progressText");
        self.progressText.innerText = "Loading...";
        self.PromptMissingInfoContainer = document.querySelector(".promptMissingInfoContainer");
        self.PromptedMissingInfoCanvas = document.querySelector(".promptMissingInfoContainer canvas");
        self.PromptedMissingInfoCanvas.width = self.WIDTH;
        self.PromptedMissingInfoCanvas.height = self.HEIGHT;
        self.PromptLabel = document.querySelector(".promptMissingInfoContainer label");
        self.PromptField = document.querySelector(".promptMissingInfoContainer .promptField");
    
        self.submitButton = document.querySelector(".promptMissingInfoContainer .promptButton");
        self.submitButton.addEventListener("click", function () {
            self.PromptFieldReturnedText = self.PromptField.value;
            self.PromptMissingInfoContainer.hidden = true;
        });
        self.autoGeneratedCffTextField = document.querySelector(".autoGeneratedCffTextField");

        
        self.copyToClipboardButton = document.querySelector("button#clipboard");

        
        self.copyToClipboardButton.onclick = function () {
            
            // Select the text field
            self.autoGeneratedCffTextField.select();
            self.autoGeneratedCffTextField.setSelectionRange(0, 99999); // For mobile devices
            navigator.clipboard.writeText(self.autoGeneratedCffTextField.value);
        }
    }

    baseData;
    nationData;
    climateData;
    coastData;
    developmentData;
    cultureData;
    religionData;
    tradeZoneData;

    populationXDevelopmentData;
    populationXDevelopmentBonusData;

    nationColorProperties;
    climateColorProperties; 
    cultureColorProperties; 
    religionColorProperties;
    tradeZoneColorProperties;

    async scanMaps() {
        self.nationColorProperties = self.fillInColorProperties(gameStats.Nations);
        self.climateColorProperties = self.fillInColorProperties(gameStats.Climates);
        self.cultureColorProperties = self.fillInColorProperties(gameStats.Cultures);
        self.religionColorProperties = self.fillInColorProperties(gameStats.Religions);
        self.tradeZoneColorProperties = self.fillInColorProperties(gameStats.TradeZones);

        self.baseData = await prepareData("Blank.png", self.progressText)
        
        self.nationData = await prepareData("Nations.png", self.progressText)
        self.climateData = await prepareData("Climates.png", self.progressText)
        self.coastData = await prepareData("CoastalLand.png", self.progressText)
        self.developmentData = await prepareData("Development.png", self.progressText)
        self.cultureData = await prepareData("Cultures.png", self.progressText)
        self.religionData = await prepareData("Religions.png", self.progressText)
        self.tradeZoneData = await prepareData("TradeZones.png", self.progressText)

        self.progressText.innerText = "loading population X development";
        await new Promise(resolve => setTimeout(resolve));

        self.populationXDevelopmentData = await self.mergeMaps(self.populationXDevelopmentMerger);

        self.progressText.innerText = "loading population X (100% + development/2)";
        await new Promise(resolve => setTimeout(resolve));

        self.populationXDevelopmentBonusData = await self.mergeMaps(self.populationXDevelopmentBonusMerger);

        self.progressText.innerText = "adjusting culture map data for population and development";
        await new Promise(resolve => setTimeout(resolve));

        let popDevAdjustedCulture = await self.mergeMaps(self.culturePopXDevBonusMerger);


        self.PromptMissingInfoContainer.hidden = false;
        self.PromptLabel.innerText = `hov!`;

        self.PromptedMissingInfoCanvas.getContext("2d").putImageData(new ImageData(popDevAdjustedCulture, self.WIDTH), 0, 0);

        self.progressText.innerText = "adjusting religion map data for population and development";
        await new Promise(resolve => setTimeout(resolve));


        let popDevAdjustedReligion = await self.mergeMaps(self.religionPopXDevBonusMerger);

        const colorToCoastMap = [
            { color: "00ffff", name: "coast"}
        ];

        let climateDistribution = await self.findDistribution(
            self.nationData, self.climateData, "nation", "climate",
            self.nationColorProperties,
            self.climateColorProperties, 
            {
                unassignedPixelAssumption: "Moderate"
            }
        );

        let coastPixelCount = await self.findDistribution(
            self.nationData, self.coastData, "nation", "coast", 
            self.nationColorProperties,
            colorToCoastMap, 
            {
                unassignedPixelAssumption: "Noncoast",
                canIgnoreTransparentInner: true
            }
        );
        
        let developmentScore = await self.findDistribution(
            self.nationData, self.developmentData, "nation", "development",
            self.nationColorProperties,
            0,
            {
                canIgnoreTransparentInner: true,
                valueMode: "greyScale" 
            }
        );
    
        let cultureDistribution = await self.findDistribution(
            self.nationData, popDevAdjustedCulture, "nation", "popdev-adjusted-culture", 
            self.nationColorProperties,
            self.cultureColorProperties,
            {
                unassignedPixelAssumption: "Foreign",
                adjustForAlpha: true
            } 
        );

        let religionDistribution = await self.findDistribution(
            self.nationData, popDevAdjustedReligion, "nation", "popdev-adjusted-religion", 
            self.nationColorProperties,
            self.religionColorProperties, 
            {
                unassignedPixelAssumption: "Pagan",
                adjustForAlpha: true
            }
        );


        let tradeZoneScore = await self.findDistribution(
            self.tradeZoneData, self.populationXDevelopmentData, "trade zone", "wealth",
            self.tradeZoneColorProperties,
            0,
            {
                canIgnoreTransparentInner: true,
                valueMode: "rbgAs24bitNum",
                unassignedPixelAssumption: 0
            }
        );

        self.autoGeneratedCffTextField.value += 
        `<... > Nations
        !suppress 99999
        
        `.trimIndents();

        //divide to make all constituencies make up 100(%). 
        Object.keys(cultureDistribution).forEach(nationKey => {
            
            let total = 0.0;

            //finding the total of all culturekey values in this nation, so we got something to divide by to find the constituencies' ratios
            Object.keys(cultureDistribution[nationKey]).forEach(CultureKey => {
                total += cultureDistribution[nationKey][CultureKey];
            });

            //replace CultureGroups by empty, before re-initialising every culture in it from scratch
            
            self.autoGeneratedCffTextField.value += 
                `> ${nationKey}
                +> CultureGroups
                > CultureGroups
                `.trimIndents();
            //dividing and adding to self.autoGeneratedCffTextField
            Object.keys(cultureDistribution[nationKey]).forEach(CultureKey => {

                self.autoGeneratedCffTextField.value += `+> ${CultureKey}\n`
                self.autoGeneratedCffTextField.value += `= ${cultureDistribution[nationKey][CultureKey] * 100 / total} ${CultureKey}.Points\n`
            });
            
            self.autoGeneratedCffTextField.value += 
                `< <
                `.trimIndents();
        });

        //divide to make all constituencies make up 100(%). 
        
        Object.keys(religionDistribution).forEach(nationKey => {
            
            let total = 0.0;

            //finding the total of all religionkey values in this nation, so we got something to divide by to find the constituencies' ratios
            Object.keys(religionDistribution[nationKey]).forEach(ReligionKey => {
                total += religionDistribution[nationKey][ReligionKey];
            });

            //replace ReligionGroups by empty, before re-initialising every religion in it from scratch
            self.autoGeneratedCffTextField.value += 
                `> ${nationKey}
                +> ReligionGroups
                > ReligionGroups
                `.trimIndents();
            //dividing and adding to self.autoGeneratedCffTextField
            Object.keys(religionDistribution[nationKey]).forEach(ReligionKey => {

                self.autoGeneratedCffTextField.value += `+> ${ReligionKey}\n`
                self.autoGeneratedCffTextField.value += `= ${religionDistribution[nationKey][ReligionKey] * 100 / total} ${ReligionKey}.Points\n`
            });
            
            self.autoGeneratedCffTextField.value += 
                `< <
                `.trimIndents();
        });

        //add climate distributions to autogeneratedccf
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        Object.keys(climateDistribution).forEach(nationKey => {
            
            
            Object.keys(climateDistribution[nationKey]).forEach(climateKey => {
                self.autoGeneratedCffTextField.value += `= ${climateDistribution[nationKey][climateKey]} ${nationKey}.${climateKey}\n`;
            });
            
        });

        //add development distributions to autogeneratedccf
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        Object.keys(developmentScore).forEach(nationKey => {
            self.autoGeneratedCffTextField.value += `= ${developmentScore[nationKey]} ${nationKey}.DevelopmentPixelCount\n`;
        });
        
        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();

        //add coast distributions to autogeneratedccf
        
        Object.keys(coastPixelCount).forEach(nationKey => {
            
            self.autoGeneratedCffTextField.value += `= ${coastPixelCount[nationKey].coast} ${nationKey}.CoastalPixels\n`;
        });

        self.autoGeneratedCffTextField.value += 
        `
        <... > Nations
        `.trimIndents();
        
        /* #region  Everthing resources */

        for (let r = 0; r < mappedResources.length; r++) {
            let resourceName = mappedResources[r];
            
            let resourceData = null;
            
            resourceData = await prepareData(`ResourcesForCode/${resourceName}.png`);
            
            self.progressText.innerText = "";

            let resourceBlobSizes = (await self.findDistribution(
                () => {return 255}, resourceData, "world", resourceName,
                [{ color: "ffffff", name: "world"}],
                (e) => { return {color: e, name: "Col" + e}},
                {
                    skipsTransparentInner: true,
                    unnamedGroup: true
                }
            ))["world"];

            //find nations' max resources

            let resourceOverlap = await self.findDistribution(
                self.nationData, resourceData, "nation", resourceName,
                self.nationColorProperties,
                (e) => { return {color: e, name: "Col" + e}},
                {
                    skipsTransparentInner: true,
                    unnamedGroup: true
                }
            );
            
            //use resourceBlobSizes to divide all. 
            
            Object.keys(resourceOverlap).forEach(nationKey => {
                let count = 0.0;

                //counting up all pixels overlapping per blob, divided by the blob's size
                Object.keys(resourceOverlap[nationKey]).forEach(ColorKey => {
                    count += resourceOverlap[nationKey][ColorKey] / resourceBlobSizes[ColorKey];
                });

                //resource blob number multiplication
                count *= mappedResourcesMultipliers[r];

                self.autoGeneratedCffTextField.value += 
                    `= ${(Math.round((count*20)) / 20).toFixed(2)} ${nationKey}.Max${resourceName}
                    `.trimIndents();
            });

        }
        
        /* #endregion */

        //add trade zone wealths to autogeneratedccf

        self.autoGeneratedCffTextField.value += 
        `
        <... > TradeZones
        `.trimIndents();


        //climate * totaldevscore (255 per pixel)
        Object.keys(tradeZoneScore).forEach(zoneKey => {
            let rawTradeZoneScore = tradeZoneScore[zoneKey];
            let idealTradeZoneScore = rawTradeZoneScore / 10000;
            self.autoGeneratedCffTextField.value += `= ${(Math.round((idealTradeZoneScore*20)) / 20).toFixed(2)} ${zoneKey}.Score\n`;
        });

        self.autoGeneratedCffTextField.value += 
        `!suppress 0
        <...
        `.trimIndents();
        
        self.progressText.innerText = `Done`

        //add to autogeneratedccf
        
        self.copyToClipboardButton.disabled = false;
    }

    fillInColorProperties(searchObj){
        let ret = [];

        Object.keys(searchObj).forEach(key => {
            ret.push({color: searchObj[key].Color, name: key});
        });

        return ret;

    }

    async findDistribution(outerDataset, innerDataset, outerName, innerName, colorToOuterNameMapping, colorToInnerNameMapping, options) {
        let ret = {};
        let pixelCount = self.WIDTH * self.HEIGHT;
        if(options.pixelCount){
            pixelCount = options.pixelCount;
        }

        let getOuterDataPoint;
        let getInnerDataPoint;

        if(typeof outerDataset != 'function')
            getOuterDataPoint = (i) => outerDataset[i];
        else
            getOuterDataPoint = (i) => outerDataset(i);

        if(typeof innerDataset != 'function')
            getInnerDataPoint = (i) => innerDataset[i];
        else
            getInnerDataPoint = (i) => innerDataset(i);

        let then = Date.now();
        for (let i = 0; i < pixelCount; i++) {
            
            let x = i % self.WIDTH;
            let y = Math.floor(i / self.WIDTH);

            //let the site know you're still alive
            let now = Date.now();
            if (now - then > 500) {
                self.progressText.innerText = `counting ${innerName}s in ${outerName}s:\n\n${i} out of ${pixelCount} pixels read.\nThat's row ${Math.floor(i / self.WIDTH)} out of ${self.HEIGHT}`
                await new Promise(resolve => setTimeout(resolve));
                then = now;
            }
            
            let outerCol;
            let innerCol;

            let isOuterDataEmpty = getOuterDataPoint(i*4+3) == 0;
            let isInnerDataEmpty = getInnerDataPoint(i*4+3) == 0;

            //if the pixel in outerDataset is transparent, skip
            if(isOuterDataEmpty) continue;
            //if the pixel in innerDataset is transparent, warn
            else if(isInnerDataEmpty) {
                if (options.skipsTransparentInner)
                    continue;
                else if(!options.canIgnoreTransparentInner)
                    console.warn(`The pixel (${x}, ${y}) is transparent in the ${innerName} image, but not the ${outerName} image. It is (${getOuterDataPoint(i*4)}, ${getOuterDataPoint(i*4+1)}, ${getOuterDataPoint(i*4+2)}, ${getOuterDataPoint(i*4+3)}) in the ${outerName} image. Investigate this. For now ${options.unassignedPixelAssumption} is assumed`);
            }

            outerCol = rgbToHex([getOuterDataPoint(i*4), getOuterDataPoint(i*4+1), getOuterDataPoint(i*4+2)]);
            innerCol = rgbToHex([getInnerDataPoint(i*4), getInnerDataPoint(i*4+1), getInnerDataPoint(i*4+2)]);

            let foundOuterObject = colorToOuterNameMapping.find(element => element.color == outerCol);

            if(typeof foundOuterObject === 'undefined') {
                foundOuterObject = await PromptName(outerCol, getOuterDataPoint, outerName);
                colorToOuterNameMapping.push(foundOuterObject);
            }

            const OuterNameOfPixel = foundOuterObject.name;
            
            if(options.valueMode = "greyScale"){
                const innerGreyScale = getInnerDataPoint(i*4);
                const InnerPixelValue = isInnerDataEmpty ? options.unassignedPixelAssumption : 255 - innerGreyScale;
                
                if(typeof ret[OuterNameOfPixel] === 'undefined') ret[OuterNameOfPixel] = 0;
                
                ret[OuterNameOfPixel] += InnerPixelValue;
            }
            else if(options.valueMode = "rbgAs24bitNum"){
                let InnerPixelValue = getInnerDataPoint(i*4+2);
                InnerPixelValue *= 255;
                InnerPixelValue += getInnerDataPoint(i*4+1);
                InnerPixelValue *= 255;
                InnerPixelValue = getInnerDataPoint(i*4);

                if(typeof ret[OuterNameOfPixel] === 'undefined') ret[OuterNameOfPixel] = 0;

                ret[OuterNameOfPixel] += InnerPixelValue;
            }
            else{
                let foundInnerObject = 
                    isInnerDataEmpty ? 
                        options.unassignedPixelAssumption : 
                        !options.unnamedGroup ? 
                            colorToInnerNameMapping.find(element => element.color == innerCol):
                            {color: innerCol, name: "Col" + innerCol};
                if(typeof foundInnerObject === 'undefined'){
                    foundInnerObject = await PromptName(innerCol, getInnerDataPoint, innerName);
                    if (!options.unnamedGroup) colorToInnerNameMapping.push(foundInnerObject);
                }
                
                const InnerNameOfPixel = foundInnerObject.name;

                if(typeof ret[OuterNameOfPixel] === 'undefined') ret[OuterNameOfPixel] = {};
                if(typeof ret[OuterNameOfPixel][InnerNameOfPixel] === 'undefined') ret[OuterNameOfPixel][InnerNameOfPixel] = 0;
                
                if(!options.adjustForAlpha)
                    ret[OuterNameOfPixel][InnerNameOfPixel]++;
                else {
                    let alpha = getOuterDataPoint(i*4+3);
                    ret[OuterNameOfPixel][InnerNameOfPixel] += alpha;
                }

            }
        }

        return ret;
    }

    async PromptName(color, getDatasetPointFunction, name){
        self.PromptFieldReturnedText = "";
        
        let DatasetLength = self.WIDTH * self.HEIGHT * 4;

        self.PromptMissingInfoContainer.hidden = false;
        self.PromptLabel.innerText = `The color #${color} did not have a matching ${name}. Which ${name} is it?\n(Give the name it has in stats)`;
        let dat = new Uint8ClampedArray(DatasetLength);
        for (let j = 0; j < DatasetLength; j++) {
            dat[j] = getDatasetPointFunction(j);
            
        }
        for(let j = 0; j < dat.length / 4; j++){
            if(rgbToHex([getDatasetPointFunction(j*4), getDatasetPointFunction(j*4+1), getDatasetPointFunction(j*4+2)]) == color){
                dat[j*4] = getDatasetPointFunction(j*4);
                dat[j*4+1] = getDatasetPointFunction(j*4+1);
                dat[j*4+2] = getDatasetPointFunction(j*4+2);
                dat[j*4+3] = getDatasetPointFunction(j*4+3);
            }
            else {
                dat[j*4] = self.baseData[j*4];
                dat[j*4+1] = self.baseData[j*4+1];
                dat[j*4+2] = self.baseData[j*4+2];
                dat[j*4+3] = self.baseData[j*4+3];
            }
            
        }

        dat = new ImageData(dat, self.WIDTH);

        self.PromptedMissingInfoCanvas.getContext("2d").putImageData(dat, 0, 0);

        console.log("ok, just waiting now :)");

        //idle until cultureNamePrompt answered;
        let then = Date.now();
        while(self.PromptFieldReturnedText == ""){
            let now = Date.now();
            if (now - then > 17) {
                await new Promise(resolve => setTimeout(resolve));
                then = now;
            }
        }

        let ret = {
            color: color, 
            name: self.PromptFieldReturnedText
        };

        self.autoGeneratedCffTextField.value += `= "${color}" ${name}s.${self.PromptFieldReturnedText}.Color\n`

        return ret;
    }

    async mergeMaps(delegate){
        let ret = new Uint8ClampedArray(self.WIDTH * self.HEIGHT * 4);

        let then = Date.now();
        for(let i = 0; i < ret.length / 4; i++) {
            let res = delegate(i*4);
            ret[i*4] = res[0];
            ret[i*4+1] = res[1];
            ret[i*4+2] = res[2];
            ret[i*4+3] = res[3];
            if(i % self.WIDTH == 0) {
                let now = Date.now();
                if (now - then > 100) {
                    let progressPercent = i / (self.WIDTH * self.HEIGHT) * 100;
                    let percentDisplay = progressPercent + "%";

                    if(Math.floor(i / self.WIDTH) > 0) self.progressText.innerText = self.progressText.innerText.replace(/\n\n.+$/, "");
                    
                    self.progressText.innerText += "\n\n" + percentDisplay;
                    await new Promise(resolve => setTimeout(resolve));
                    then = now;
                }
            }
        }

        return ret;
    }

    populationXDevelopmentMerger(mapIndex){
        let foundZoneColor = rgbToHex([self.nationData[mapIndex], self.nationData[mapIndex+1], self.nationData[mapIndex+2]]);
        let climateObject = self.climateColorProperties.find(element => element.color == foundZoneColor);
        let climateScore = climateObject ? gameStats.Climates[climateObject.name].ClimateScore : 0;
        let ret = climateScore * self.developmentData[mapIndex];

        let lsbyte = ret % 256;
        let msbyte = Math.floor(ret / 256);

        return [0, msbyte, lsbyte, 255];
    }

    populationXDevelopmentBonusMerger(mapIndex){
        let foundZoneColor = rgbToHex([self.nationData[mapIndex], self.nationData[mapIndex+1], self.nationData[mapIndex+2]]);
        let climateObject = self.climateColorProperties.find(element => element.color == foundZoneColor);
        let climateScore = climateObject ? gameStats.Climates[climateObject.name].ClimateScore : 0;
        let ret = climateScore * (128 + self.developmentData[mapIndex] / 2);
        
        let lsbyte = ret % 256;
        let msbyte = Math.floor(ret / 256);
        
        return [0, msbyte, lsbyte, 255];
    }

    culturePopXDevBonusMerger(mapIndex){
        let ret = [];
        ret[mapIndex] = self.cultureData[mapIndex];
        ret[mapIndex+1] = self.cultureData[mapIndex+1];
        ret[mapIndex+2] = self.cultureData[mapIndex+2];
        if(self.populationXDevelopmentBonusData[mapIndex+1] != 0) error("The value of populationXDevelopmentBonusData is higher than expected.")
        ret[mapIndex+3] = self.populationXDevelopmentBonusData[mapIndex+2];
        
        return ret;
    }

    religionPopXDevBonusMerger(mapIndex){
        let ret = [];
        ret[mapIndex] = self.religionData[mapIndex];
        ret[mapIndex+1] = self.religionData[mapIndex+1];
        ret[mapIndex+2] = self.religionData[mapIndex+2];
        if(self.populationXDevelopmentBonusData[mapIndex+1] != 0) error("The value of populationXDevelopmentBonusData is higher than expected.")
        ret[mapIndex+3] = self.populationXDevelopmentBonusData[mapIndex+2];
        
        return ret;
    }

}

new MapCCFCalculations();

/*

Generates:

<... > Nations
!suppress 99999

> test
+> CultureGroups
> CultureGroups
+> eu
= 83.38684172696344 eu.Points
+> af
= 9.535674924529205 af.Points
+> as
= 0.17250467200153338 as.Points
+> am
= 6.904978676505822 am.Points
< <
> test
+> ReligionGroups
> ReligionGroups
+> west
= 100 west.Points
< <

<... > Nations
= 18297 test.Moderate
= 631 test.CoastalDesert
= 762 test.SubTropical
= 1179 test.Tropical

<... > Nations
= 3822745 test.DevelopmentPixelCount

<... > Nations
= 10644 test.CoastalPixels

<... > Nations
= 0.75 test.MaxGold
= 2.25 test.MaxIron
= 0.20 test.MaxIvory
= 2.10 test.MaxSulphur
= 4.00 test.MaxCoal

<... > TradeZones
= 0.00 CentralSiberia.Score
= 3.75 EasternSiberia.Score
= 0.20 WesternSiberia.Score
= 0.00 NorthSea.Score
= 1.20 Alaska.Score
= 0.00 NorthernNordics.Score
= 0.00 HudsonBay.Score
= 0.15 BarentsSea.Score
= 0.00 CentralCanada.Score
= 0.00 BalticSea.Score
= 0.00 Novgorod.Score
= 0.00 Denmark.Score
= 1.15 LawrenceGulf.Score
= 0.00 Volga.Score
= 0.80 Livonia.Score
= 0.00 BritishIsles.Score
= 0.00 Muscovy.Score
= 0.95 Dniepr.Score
= 0.00 UralRiver.Score
= 0.00 Manchuria.Score
= 0.00 Vistula.Score
= 0.00 CentralEurope.Score
= 0.00 DonRiver.Score
= 0.00 Cascadia.Score
= 0.00 SeaOfJapan.Score
= 0.00 Rhine.Score
= 0.00 EnglishChannel.Score
= 0.00 GreatLakes.Score
= 0.00 Romania.Score
= 0.00 CentralAsia.Score
= 0.00 France.Score
= 0.00 WesternDanube.Score
= 0.00 EasternDanube.Score
= 0.00 TheRockies.Score
= 0.00 Mississippi.Score
= 0.00 SouthernFrance.Score
= 0.00 CaspianSea.Score
= 0.00 GobiDesert.Score
= 0.00 Crimea.Score
= 0.00 BayOfBiscay.Score
= 0.00 Adriatic.Score
= 0.00 EastCoast.Score
= 0.00 CentralMediterranean.Score
= 0.00 WestCoast.Score
= 0.00 Caucasus.Score
= 0.00 Greece.Score
= 0.00 WesternMediterranean.Score
= 0.00 Iberia.Score
= 0.00 NorthernAnatolia.Score
= 0.00 YellowRiver.Score
= 0.00 Mesopotamia.Score
= 0.00 EasternMediterranean.Score
= 0.00 GulfOfMexico.Score
= 0.00 Afghanistan.Score
= 0.00 IndusRiver.Score
= 0.00 Morocco.Score
= 0.00 Tibet.Score
= 0.00 Iran.Score
= 0.00 Sichuan.Score
= 0.00 Sahara.Score
= 0.00 ArabianDesert.Score
= 0.00 YangtzeRiver.Score
= 0.00 WesternMexico.Score
= 0.00 Egypt.Score
= 0.00 Ganges.Score
= 0.00 RedSea.Score
= 0.00 PersianGulf.Score
= 0.00 Caribbean.Score
= 0.00 WesternSahara.Score
= 0.00 SouthEastAsia.Score
= 0.00 Pacific.Score
= 0.00 SouthChinaSea.Score
= 0.00 CentralIndia.Score
= 0.00 Deccan.Score
= 0.00 SouthernNile.Score
= 0.00 Somalia.Score
= 0.00 WesternNiger.Score
= 0.00 Guinea.Score
= 0.00 CentralAmerica.Score
= 0.00 EasternNiger.Score
= 0.00 Venezuela.Score
= 0.00 Indonesia.Score
= 0.00 CongoRiver.Score
= 0.00 Gabon.Score
= 0.00 LakeVictoria.Score
= 0.00 Amazon.Score
= 0.00 Peru.Score
= 0.00 EastAfrica.Score
= 0.00 LakeTanganyika.Score
= 0.00 SaoFranciscoRiver.Score
= 0.00 NorthernAustralia.Score
= 0.00 Angola.Score
= 0.00 Mozambique.Score
= 0.00 ParanaRiver.Score
= 0.00 Chile.Score
= 0.00 SouthernAustralia.Score
= 0.00 SouthAfrica.Score
= 0.00 AustralianDesert.Score
= 0.00 Patagonia.Score
!suppress 0
<...


*/
